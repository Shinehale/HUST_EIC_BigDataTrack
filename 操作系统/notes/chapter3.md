# Chapter 3

### Bernstein条件

$R(p_i) = \{a_1, a_2, \cdots, a_n\}$，程序$p_i$在执行期间引用的变量集；

$W(p_i)=\{b_1, b_2, \cdots, b_m\}$，程序$pi$在执行期间改变的变量集；

若两个程序的变量集交集之和为空集:

$R(p1)∩W(p2)∪R(p2)∩W(p1)∪W(p1)∩W(p2)=\{\}$

则并发进程的执行与时间无关

### 采用并发程序设计的目的

- 充分发挥硬件的并行性，提高系统效率。硬件能并行工作仅有了提高效率的可能性，硬部件并行性
的实现需要软件技术去利用和发挥，这种软件技术就是并发程序设计。
- 并发程序设计是多道程序设计的基础，多道程序的实质就是把并发程序设计引入到系统中。


```cpp
bool inside[2];
inside[0] = false;
inside[1] = false;
enum {0, 1} turn;

cobegin
  process P0() {
    inside[0] = true;
    turn = 1;
    while (inside[1] && turn == 1);
    /* 临界区 */
    inside[0] = false;
  }

  process P1() {
    inside[1] = true;
    turn = 0;
    while (inside[0] && turn == 0);
    /* 临界区 */
    inside[1] = false;
  }
coend
```


关中断

禁止一切中断发生。
单CPU中，引起进程切换的唯一原因是中断，故单CPU下可行。
缺点：
代价高，影响并发性
不安全，将禁止一切中断权利给了普通用户。
局限性：不适合多CPU，一个进程只能禁止本CPU的中断。

硬件指令方法的缺点

忙等待：上述硬件指令虽然可以有效的保证进程间互斥，但是进程在临界段中执行时，其他想进入临界段的进程必须不断地检测布尔变量lock的值，这就造成了处理机时的浪费，通常称这种情况为“忙等待”。 
饥饿：由于采用随机从等待队列中选取进程，会出现有的进程一直处于等待。
需CPU支持。
youdian:
不但适用于单处理器情况，而且适用于共享主存的SMP多处理器情况（即对称多处理器）；
方法简单，行而有效；
可以被使用于多重临界段情况，每个临界段可以定义自己的共享变量。

信号量按其取值分为
二元信号量：信号量的值仅允许取0或1，主要用于互斥变量。
一般信号量：信号量取值允许为非负整数，主要用于进程间的一般同步
设s为一个记录型数据结构，一个分量为整形量value，另一个为信号量队列queue，P和V操作原语定义：
P(s)：将信号量s减去l，若结果小于0，则调用P(s)的进程被置成等待信号量s的状态。
V(s)：将信号量s加1，若结果不大于0，则释放一个等待信号量s的进程。

```cpp
typedef struct semaphore {
    int value;             /*信号量值*/
    struct pcb *list;    /*信号量队列指针*/
}; 
void P(semaphore &s) {
     s.value--;            
     if(s.value<0)  sleep(s.list);      
}                     
void V(semaphore &s) {
    s.value++;            
       if(s.value<=0)    wakeup(s.list);        
}                      
```

信号量S的初值表示可用资源数
当S>0时，S的值表示还剩可用资源数
当S<=0时，表示已无资源可分配，其绝对值表示此时在等待队列中等待分配资源的进程数
Wait操作：申请资源，若S>0，意味着有资源可以申请，操作后，S=S-1意味着资源减少
Signal操作：释放资源，执行Signal操作之后，S=S+1,意味着资源数增加


信号量的变化范围：
设可用资源数为m，进程数为n
阻塞等待： -(n-m)<=S <=m
为临界资源设置一个互斥信号量mutex，其初值为N（系统提供的同类资源最大数目）；在每个进程中将临界区代码置于P(mutex)和V(mutex)原语之间。
必须成对使用P和V原语：遗漏P原语则不能保证互斥访问，遗漏V原语则不能在使用临界资源之后将其释放（给其他等待的进程）；
P、V原语不能次序错误、重复或遗漏。


生产者消费者
信号量设置
4个临界资源，分别需要4个信号量
(1)空仓，Empty：表示空的缓冲区数，初值为k
(2)产品，Full：表示满的缓冲区数，初值为0；
(3)空仓头指针，Mutex_P0：分配空仓缓冲区的互斥信号量，初值为1。
    (4)产品链头指针，Mutex_C0：分配空产品链的互斥信号量，初值为1。

```cpp
item B[k];
semaphore Empty; Empty = k;  /* 可以使用的空缓冲区数 */
semaphore Full; Full = 0;    /* 缓冲区内可以使用的产品数 */
semaphore Mutex_P0; Mutex_P0 = 1;  /* 互斥信号量 */
semaphore Mutex_C0; Mutex_C0 = 1;  /* 互斥信号量 */
int in = 0;   /* 放入缓冲区指针 */
int out = 0;  /* 取出缓冲区指针 */

cobegin
  process producer_i() {
    while (true) {
      produce();
      P(Empty);
      P(Mutex_P0);
      append to B[in];
      in = (in + 1) % k;
      V(Mutex_P0);
      V(Full);
    }
  }

  process consumer_j() {
    while (true) {
      P(Full);
      P(Mutex_C0);
      take() from B[out];
      out = (out + 1) % k;
      V(Mutex_C0);
      V(Empty);
      consume();
    }
  }
coend
```
信号量变化范围
(1)空仓Empty：[-n,k];
(2)产品Full：[-m,k]；
(3)空仓头指针，Mutex_P0：[-(n-1),1]；
    (4)产品链头指针，Mutex_C0：[-(m-1),1]。



读写者问题

有两组并发进程：读者和写者，共享一个文件F，要求：
允许多个读者同时执行读操作；
只允许一个写者执行写操作；
任一写者在完成写操作之前不允许其它读者或写者工作；
写者执行写操作前，应让已有的写者和读者全部退出。

A、资源1：int 	ReadCount=0； 
/*阅读者进程计数器*/
semaphore Mutex_ReadCount=1；
B、资源2：BUF
semaphore Mutex_BUF=1

信号量变化范围
(1)阅读者计数器的信号量
Mutex_ReadCount：[-(m-1),1];
(2)BUF的信号量Mutex_BUF：[-n,1]

```cpp
process reader_i() {
  while (1) {
    /* 读者计数器累加 */
    P(Mutex_ReadCount);
    readcount++;
    /* 第一个读者去申请BUF */
    if (readcount == 1)
      P(Mutex_BF);
    V(Mutex_ReadCount);
    
    /* 读文件 */
    
    /* 读者计数器递减 */
    P(Mutex_ReadCount);
    readcount--;
    /* 最后一个读者去释放BUF */
    if (readcount == 0)
      V(Mutex_BF);
    V(Mutex_ReadCount);
    
    sleep(10);
  }
}

process writer_j() {
  while (1) {
    P(Mutex_BF);
    /* 写文件 */
    V(Mutex_BF);
    sleep(10);
  }
}

```



理发店理有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子；
如果没有顾客，理发师便在理发椅上睡觉
一个顾客到来时，它必须叫醒理发师；
如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，就坐下来等待，否则就离开。
```cpp
int waiting=0;  /*等候理发顾客坐的椅子数*/
int CHAIRS=N; /*为顾客准备的椅子数*/
semaphore customers,barbers,mutex;
customers=0;barbers=0;mutex=1;
cobegin
process barber( ) {
    while(true) {
          P(customers);/*有顾客吗？若无顾客，理发师睡眠*/
          P(mutex);           /*若有顾客时，进入临界区*/
          waiting--;           /*等候顾客数少一个*/
          V(barbers);        /*理发师准备为顾客理发*/
          V(mutex);          /*退出临界区*/
          cut_hair();         /*理发师正在理发(非临界区)*/
     }
}
process customer_i( ) {
        P(mutex);                //进入临界区
        if(waiting<CHAIRS) {     //有空椅子吗
              waiting++;         //等候顾客数加1
              V(customers);      //唤醒理发师
              V(mutex);            //退出临界区
              P(barbers);          //理发师忙，顾客坐下等待
              get_haircut();      //否则顾客坐下理发
        }
        else
              V(mutex);           //人满了，走吧！
}
coend
```


管程与进程的区别：
(1) 虽然二者都定义了数据结构，但进程定义的是私有数据结构PCB，而管程定义的是公共数据结构，如条件变量等；
(2) 二者都存在对各自数据结构上的操作，但进程是顺序执行的，而管程则是进行同步操作和初始化操作；
(3) 进程是为了保证系统并发而设计的，管程则是为了解决共享资源的互斥；
(4) 进程通过调用管程中的过程来进行共享数据结构的操作，该过程就表现为进程的子程序，因此进程是主动的，管程是被动的；
(5) 进程间可并发，管程作为子程序不能与其调用者并发；
(6) 进程具有动态性和生命周期，而管程只是一个资源管理模块，供进程调用。


wait操作的含义：
    x.wait表示正在调用管程的进程因x条件需要被阻塞或挂起，该进程在执行wait操作时将自己插入x条件的等待队列中，并释放管程。此时其它进程可以使用该管程完成自身工作，当x条件产生变化时，系统调度程序将选择等待队列中的一个进程继续执行。
signal操作的含义：
    x.signal表示正在调用管程的进程发现x条件发生了变化，则使用signal操作唤醒一个因x条件被阻塞或挂起的进程。
当一个管程中的过程发现自身无法运行下去(如生产者进程发现缓冲池满)时，它将对某个条件变量(如full)执行wait操作。该操作会阻塞调用进程自身，并将其它在管程外等待的进程调入管程。

```cpp

monitor ProducerConsumer
    condition full,empty;
    int count;
    void insert(int item)
    {
        if (count==N) wait(full);
        insert(item);
        count=count+1;
        if (count==1) signal(empty);
    }
    int remover()
    {
        if (count==0) wait(empty);
        remove=remove_item;
        count=count-1;
        if (count==N-1) signal(full);
    }
    count=0;
end monitor

void producer()
{
        while (true) 
        {
           item=produce_item;
           ProducerConsumer.insert(item);
        }
}
void consumer()
{
        while (true) 
        {
           item=ProducerConsumer.remove;
           consume(item)
        }
}

```



要求发送进程和接收进程都以显示的方式提供对方的标识符。通常系统提供两条通信原语。
原语send（P，消息）：把一个消息发送给进程P
原语receive（Q，消息）：从进程Q接收一个消息
通常一个进程可以与多个进程通信，即可以向多个进程发送消息，也可以接收来自多个进程的消息。为了便于进程接收和处理这些消息，一般采用消息队列通信机制，将消息组织成消息队列，用链指针链接起来，头指针放在进程的PCB中。
```cpp
PCB中部分数据
    type PCB ＝ record
            ……
        Msgmq； 首指针
        MsgMutex；互斥信号量
        MsgSm；    资源信号量
          ……
    end

```


死锁定义：死锁是指系统中的一组进程，由于竞争系统资源或由于彼此通信而永远阻塞，称这些进程处于死锁状态。
死锁的产生是与资源分配策略和并发进程执行的速度有关 


进程竞争资源，而资源不足
    当系统中供多个进程所共享的资源不足以同时满足进程的需要时，就可能引起进程对资源的竞争而产生死锁。
进程推进顺序不合适
    在进程运行过程中，当请求和释放资源的顺序不当时，可能会导致进程死锁



设系统某类资源有m个，有n个进程，每个进程需要K个该资源，则当满足
    nk<= m+(n-1)时，系统不会引起死锁。


Coffman等人（1971）总结死锁产生的四个必要条件：
互斥条件
不剥夺条件
部分分配
环路条件

互斥条件：一个资源一次只能被一个进程所使用。
不可抢占条件：一个资源仅能被占有它的进程所释放，而不能被其他的进程强行抢占。
部分分配条件：一个进程已占有分给它的资源，但仍然要求其他资源。
循环等待条件：在系统中存在一个由若干个进程形成的环形请求链，其中的每一个进程均占有若干种资源中的某一种，同时还要求下一个进程所占有的资源。



资源的分类
根据资源是否可抢占
可抢占资源：指资源占有者进程虽然仍需要使用资源，但系统可以根据某原则强行将该资源剥夺，分配给其他进程。
不可抢占资源：指资源一旦被进程占有，只有当进程不再使用而主动释放资源外，其他进程不得强行抢占其资源。
根据资源使用方式
共享资源：指资源同时可以为多个进程共同使用。
独享资源：指资源同一时刻只能为一个进程单独使用
进程因竞争独享、不可抢占资源而发生死锁。

处理死锁有三种基本方法：
死锁的预防
死锁的避免
死锁的检测和恢复


死锁的预防主要通过设置某些限制条件，破坏死锁产生的必要条件，以达到不产生死锁的目的。
破坏第一个条件（互斥条件）：使资源可同时访问而不是互斥使用，
破坏第二个条件（部分分配条件）：采用预先静态分配法
破坏第三个条件（不剥夺条件）：采用剥夺式调度方法
破坏第四个条件（循环等待条件）：采用层次分配策略

预先静态分配法
实质：破坏部分分配条件
实现：在进程开始运行之前，一次分配给其所需的全部资源，若系统不能满足，则进程阻塞，直到系统满足其要求。
优点：简单，易于实现且安全
缺点：
资源严重浪费。
延迟运行。



有序资源使用法
实质：破坏循环等待条件
实现：
把资源分类，按序排列，每种资源分配唯一序号；
进程对资源的请求必须严格按资源序号的递增次序申请；
经常用的普通的资源低序号，贵重少用的高序号。
优点：基于动态分配，资源利用率提高
缺点：
由于资源序号必须相对稳定，限制了新设备类型的增加；
存在资源申请次序与实际使用次序不一致，导致利用率不高。



系统安全性定义：在时刻T0系统是安全的，仅当存在一个进程序列P1,..,Pn，对进程Pk满足公式：

        Need[k,i] ≤Available [i]+ ∑Allocation[j,i]          
                               k=1,…,n;
                               i=1,…,m; 

死锁定理

(1)如果进程-资源分配图中无环路，则此时系统没有发生死锁。
(2)如果进程-资源分配图中有环路，且每个资源类中仅有一个资源，则系统中发生了死锁，此时，环路是系统发生死锁的充要条件，环路中的进程便为死锁进程。
(3)如果进程-资源分配图中有环路，且涉及的资源类中有多个资源，则环路的存在只是产生死锁的必要条件而不是充分条件。
如果能在进程-资源分配图中消去此进程的所有请求边和分配边，成为孤立结点。经一系列简化，使所有进程成为孤立结点，则该图是可完全简化的；否则则称该图是不可完全简化的。
系统为死锁状态的充分条件是：当且仅当该状态的进程-资源分配图是不可完全简化的。该充分条件称为死锁定理。

一种具体死锁检测方法，检测算法步骤如下：
（１）Available [m]是长度为 m 的向量，说明每类资源中可供分配的资源数目 。
（２）Allocation[n,m] 是 n × m 矩阵，说明已分配给每个进程的每类资源数目 。
（３）Request [n,m]是 n × m 矩阵，说明当前每个进程对每类资源的申请数目 。
（４）Work [m]是长度为 m 的工作向量 。
（５）finish [n]是长度为 n 的布尔型工作向量 。


