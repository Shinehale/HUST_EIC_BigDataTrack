# Chapter 4

存储管理的主要功能
主存分配和回收：
主要任务：将主存分配给多个程序，以提高主存利用率。
选择合适的分配和回收算法及相应的数据结构，以提高主存利用率和分配、回收的速度。
地址转换和重定位：
主要任务：屏蔽物理内存使用细节，解决用户程序装入（可以部分装入）。
可执行文件生成中的链接技术
程序加载(装入)时的重定位技术
进程运行时硬件和软件的地址变换技术和机构

## 存储器工作原理

为什么程序使用逻辑地址而不是物理地址？
用户需要精确计算空间与存放地址；
支持多道程序运行十分困难；
程序的可移植性差。

编译程序负责记录引用发生的位置，编译或汇编的结果产生相应的多个目标代码模块，每个都附有供引用使用的内部符号表和外部符号表。符号表中依次给出每个符号名及在本目标代码模块中的名字地址，在模块被链接时进行转换。
链接需要解析内部和外部符号表，把对符号名字引用转换为数值引用，要转换每个涉及名字地址的程序入口点和数据引用点成为数值地址。
装入时根据指定的内存块首地址，再次修改和调整被装载模块中的每个逻辑地址，将逻辑地址绑定到物理地址。

根据程序链接发生的时刻和链接方式，可分成三种：
 (1)静态链接
 (2)动态链接
 (3)运行时链接

装载程序（loader）把可执行程序装入内存方式有三种：
(1)绝对装载：装载模块中的指令地址始终与其内存中的地址相同，即在模块中出现的所有地址都是内存绝对地址。
(2)可重定位装载：根据内存当时使用情况，决定将装载代码模块放入内存的物理位置。模块内使用的地址都是相对地址。
(3)动态运行时装载：为提高内存利用率，装入内存的程序可换出到磁盘上，适当时候再换入到内存中，对换前后程序在内存中的位置可能不同，即允许进程的内存映像在不同时候处于不同位置，此时模块内使用的地址必为相对地址。

可执行程序逻辑地址转换 （绑定）为物理地址的过程称地址重定位 、地址映射或地址转换，基于上述程序装载方式，可区分三种地址重定位。
(１) 静态地址重定位
(２) 动态地址重定位
( 3 ) 运行时链接地址重定位

动态重定位：在程序执行时由系统硬件完成从逻辑地址到物理地址的转换。
 系统中设置了重定位寄存器。
 动态重定位是由硬件地执行时完成的，程序中不执行的程序就不做地址映射的工作，这样节省了CPU的时间 。
 重定位寄存器的内容由操作系统用特权指令来设置，比较灵活。
 实现动态地址映射必须有硬件的支持，并有一定的执行时间延迟。现代计算机系统中都采用动态地址映射技术。

固定分区存储管理
基本概念 ：
    把主存分成若干个固定大小的存储区，每个分区给一个作业使用，直到该作业完成后才将该区归还系统。
固定指各分区的位置和大小固定。通常在系统启动后就确定了。
分区可分为用户分区和系统分区，用户分区存放用户程序，系统分区存放系统程序和管理信息。
2、用户分区的划分可用两种方式
分区大小相等：指所有的用户分区大小都相等。
缺点：
程序小于分区大小，可能出现内部碎片，造成主存浪费
程序大于分区，程序无法在一个分区内装入，导致程序无法运行。
分区大小不等：指所有用户分区的大小并不都相等
克服分区大小相等的缺点，一般划分出多个较小的分区、适量中等分区和少量大分区。小程序分配小分区。

存储分块表（MBT）
当分区大小不等时，系统需要对每个分区的信息进行记录，以便管理。
用来存储分区管理信息的数据基。
MBT中一般记录三项信息
大小：存储块的大小，以字节为单位
位置：存储块在主存中的起始地址
状态：存储块是否使用标记  
   MBT一般放在系统分区内，通常由存储分配和释放两个模块对它进行操作。
  MBT在系统分区占用一个连续的内存空间
优点
管理简单；
硬件支持要求少，一对界地址寄存器；
缺点
主存利用率不高，存在内部碎片。
分区总数固定，限制了并发执行的程序数目。
采用静态重定位。
可以采用一对界地址寄存器实现储存器保护

最优适应法
定义：按分区的在内存的次序从头查找，找到其大小与要求相差最小的满足要求的空闲分区进行分配。
思想：避免“大材小用”，使分区内未用部分最少。
为了便于查找，一般对空闲存储块由小到大顺序排列，这样，第一次找到的满足要求的空闲块就是最佳的空闲块。
缺点：孤立地看，该方法似乎是最优的，然而，从宏观和长远看，由于每次剩余的部分重是最小的，这样，在主存中会留下许多难以利用的小空闲区（外部碎片）。
优点：较大的空闲分区可以被保留。

最先适应法
定义：按分区在内存的先后次序从头查找，找到符合要求的第一个分区进行分配。
分析：由于分区序号通常由低向高排列，因此，该算法倾向于优先利用主存的低地址部分的空闲分区，高地址的空闲分区很少被利用，可以保留高端大空闲区。
一般要求对空闲分区按地址递增的次序排列。
优点：该算法的分配和回收的时间性能较好，可以保留高端大空闲区。
缺点：随着低端分区不断划分，低端会出现很多较小的空闲分区，由于分配查找从低端开始，因此查找时间开销会增大。  

最坏适应法
定义：按分区在内存的先后次序从头查找，找到最大的满足要求的空闲分区进行分配。
一般要求对空闲存储块按其大小以递增顺序排列。
优点：减少了最佳适应法中出现过多外部碎片的缺点。
缺点：不利于大作业的分配。

内存紧凑和程序浮动带来的问题：
经过紧缩后，用户程序在内存中的位置发生了变化，若要程序能正确运行，必须对程序代码和数据的地址进行变换，即进行重定位。
静态重定位不行，最好的方法是采用动态重定位。
采用动态重定位技术，由于地址转换在程序执行期间，随着对每条指令和数据的访问而自动进行，因此，当系统进行紧缩和程序浮动时，不需要对程序做任何修改，只需将程序在主存的起始地址进行更新即可。
移动算法的实施时机
方式1：在某分区被释放后立即进行紧缩。
优点：系统主存非常整洁，只有一个连续的空闲分区，没有任何碎片，有利于空闲分块表的管理和主存分配 。
缺点：紧缩工作需要耗费系统资源，会降低CPU利用率和系统吞吐量。
方法2：当“请求分配模块”找不到足够大的空闲分区时，再进行紧缩
优点：减少紧缩次数，提高CPU利用率和系统吞吐量。
缺点：增加了空闲分块表管理的复杂性。

对换技术
作用：解决多个程序存在而导致内存区不足。
对换技术：通过选择一个进程，把其暂时移出到磁盘，腾出空间给其他进程使用，同时把磁盘中的某个进程再换进内存，让其投入运行，这种互换称对换。
对换进程选择：把时间片耗尽或优先级较低的进程换出，因为短时间内它们不会被投入运行；
数据区和堆栈是进程运行时创建和修改的，可通过文件系统把这些可变信息作为特殊文件移出。
由OS控制内存与外存信息交换。
批处理系统中，当有进程要求动态扩充内存且得不到满足时可触发对换；
分时系统中，对换可与调度结合在一起，每个时间片结束或执行I/O操作时实施。  
进程一旦因时间片到或因等待事件而不能运行时，它不但让出CPU，而且也要释放出其所占有的主存空间，并且把该进程的程序和数据以文件的形式保存在外存中。
直到调度程序再次调度到它时，才重新进入主存运行，这时又把它的程序和所需数据送入主存。

覆盖技术
作用：解决用户程序长度超出物理内存总和。
覆盖技术：指一个作业的若干程序段（或数据段）间，或几个作业的某些部分间共享某主存空间。
用于OS：OS常用部分常驻内存，不常用部分存于外存;
用于用户作业：用户指定各程序段调入内存的先后次序，以及内存中可以覆盖的程序段位置。
不足：由用户程序自己控制内外存信息交换，用户负担很重，且程序不宜过长，用于早期的OS。

逻辑地址表示：
在分页系统中，每个逻辑地址用一个数对表示：  （p,d）
    其中：p：页号；
               d：页内偏移地址。

例如：逻辑地址A，页大小为 L，则：
p = INT[A/L]  d = A mod L
主存分配原则
主存以页架为单位进行分配；
分配的页架可以连续，也可以不连续；
可以将作业的任意一页放入主存的任意一页架中；
作业所有页一次性全部装入主存，若主存空间不够，则作业等待。

页表
定义：用于管理和维护进程页和页架映射关系的数据结构，称为页表，也叫页映象表，记为PMT。
系统创建进程时，同时为其产生一个PMT。进程结束时，PMT删除。
每个进程的页表存放在主存的一个连续地址空间中。
系统中有一个页表寄存器，用来存放当前正在运行的进程的页表起始地址和页表长度。

简单分页优缺点
优点
主存利用率高，不存在页外碎片，极少页内碎片，存在于每个进程最后页内。
主存分配和释放快。
分区管理简单。
缺点：
要求一次将进程全部页装入主存；
存在页内碎片。

## 分段存储管理

1、段的定义：一组逻辑信息的集合。
2、分段的引入：主要目的是为了满足用户在编程和内存使用上要求：
方便编程：通常，一个程序是由若干个自然段组成，因而，用户希望能够把程序按逻辑关系分成若干个段，每个段有段名和长度，用户程序在执行时可按段名和段内地址进行访问。
共享和保护：在实现程序和数据共享和保护时，都是以信息逻辑单位为基础的，比如，共享例程和函数。而在分页系统中，每页是存放信息的物理单位，本身并没有完整的意义，因而不便于实现信息共享和保护，而段是信息的逻辑单元 。

主存分配：
以段为单位进行主存分配 ；
段内连续存放：每段分配一个连续的主存物理空间；
段间可以不连续：段和段之间在主存中地址可以是离散的。

段表：
定义：用于记录和管理进程分段信息的数据表称为段表。段表应包含：段号、段长和段的主存起始地址。
系统创建进程时,同时为其产生一个段表。进程结束时，段表删除。
每个进程的段表存放在主存的一个连续地址空间中。
系统中由一个段表寄存器中，存放进程的段表的起始地址和段表长度。  
简单分段的特点：
没有内部碎片；
便于共享和保护；
存在外部碎片；
由于段内连续分配，段的长度受内存空闲区大小的限制；
需要更多硬件支持。

页式和段式系统的区别
不同点：
页是信息的物理单位，分页是为了实现离散分配方式，以减少内存的碎片，提高内存利用率。或者说，分页仅仅是由于系统管理的需要，而不是用户的需要。
    段是信息的逻辑单位，它含有一组其意义相对完整的信息，分段的目的是为了能更好地满足用户的需要。
页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分是由硬件实现的，因而，一个系统只能有一种大小的页面。
    段的长度不固定，取决于用户编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分
分页的逻辑地址空间是一维的，即单一的线性地址空间，程序员只需利用一个地址符。即可表示一个地址。
    分段的逻辑地址空间是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。
相同点
采用离散分配方式；
通过地址映射机构实现地址变换。

## 虚拟存储管理

程序运行的局部性特性
指程序在执行过程中的一个较短时间内，所执行的指令地址或操作数地址分别局限于一定的存储区域中。又可细分时间局部性和空间局部性。
时间局部性
指程序中的某条指令一旦被执行，则在较短的时间内，该指令可能被再执行，某个数据被访问，则在较短的时间内，该数据可能被再次访问。  
空间局部性
指一旦程序访问了某个存储单元，在较短的时间内，其附近的存储单元很可能也被访问。即程序在一段时间内所访问的地址，可能集中在一定的范围内。

请求分页虚存管理页表扩展
驻留标志位(又称中断位)
修改位（Modified）
引用位（Renferenced）
保护位  (Protected)
页面号 (Page Number)
内存块号(Frame Number)

MMU主要功能
(1)管理硬件页表基址寄存器。
(2)分解逻辑地址。
(3)管理快表TLB。
(4)访问页表。
(5)发出缺页中断或越界中断，并将控制权交给内核存储管理处理。
(6)设置和检查页表中各个特征位。

直接映象的页地址转换
特点：
降低了CPU执行指令的速度，访问一个实际物理地址，至少需要访问两次内存，从而使速度将为1/2。
每个进程一个页表，页表的全部表项装在一个地址连续的内存空间。
只适合小进程地址空间。

段页式存储管理的数据结构包括：
作业表：登记进入系统中的所有作业及该作业段表的起始地址，
段表：包含这个段是否在内存，以及该段页表的起始地址等，
页表：包含该页是否在内存(中断位)、对应内存块号。
从逻辑地址出发，先以段号s和页号p作索引去查快表，如果找到，那么立即获得页p的页框号p’，并与位移d一起拼装得到访问内存的实地址，从而完成了地址转换。
若查快表失败,就要通过段表和页表作地址转换了，用段号s作索引，找到相应表目，由此得到s段的页表起址s’，再以p作索引得到s段p页对应的表目,得到页框号p’；这时一方面把s段p页和页框号p’置换进快表，另一方面用p’和d生成内存实地址，从而完成地址转换。
如查段表时，发现s段不在内存，产生“缺段中断”，引起系统查找s段在外存的位置，将该段页表调入内存；
如查页表时，发现s段的p页不在内存，产生“缺页中断”，引起系统查找s段p页在外存的位置，并将该页调入内存，当内存已无空闲页框时，就会导致淘汰页面。
段页式虚存管理优缺点
优点
基本上结合了段式和页式的优点，克服了两者的缺点
以页架为单位分配主存，主存利用率比段式高，消除了段式的外部碎片，无紧缩问题；
段页式的共享和保护实现与段式一样，比页式好，自需段表中的相应表目指向共享段在主存中页表地址即可。
段页式的动态扩充实现的比段式和页式都好，既不受逻辑相邻的限制，也不受物理相邻的限制
缺点
和页式一样存在页内碎片，其页内碎片比页式多。页式平均每个程序有一页有碎片，段页式则是平均每段有一页有碎片。
增加了硬件成本。
增加了软件复杂性和管理开销
